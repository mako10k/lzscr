# lzscr 型定義（μ型／isorecursive）設計メモ

この文書は、型定義の新設（%宣言）と内部表現としての μ 型（isorecursive）の導入方針をまとめた設計メモです。まずは仕様の合意を取り、その後段階的に実装します。

## 目的
- List 専用の当て推量を撤廃し、一般の再帰的 ADT を健全に扱う。
- 多相関数の型注釈で名前付き型（List/Option など）を使えるようにする。
- 既存の型推論（HM）と両立させる（停止性・エラーメッセージの改善）。

## 方針（案C）
- ユーザの型定義は `%` 宣言で記述。
- 自己参照は “同形自己参照” を検出して内部的に μ 型へ変換（isorecursive）。
- ユニフィケーションは「必要時に μ を1段だけ展開」する戦略で運用。
- 既知ファミリ（List/Option/Bool 等）は型名で表示・注釈可能にしつつ、内部構造と相互変換可能にする。

## 構文（ドラフト）
- トップレベル型宣言
  - `%TypeName %a %b = %{ .Tag 型式 | .Tag 型式 | ... }`  // 和（sum）
  - 将来: `%TypeName %a ... = %record{ field: 型式, ... }`  // レコード
- 例
  - `%Option %a = %{ .Some %a | .None }`
  - `%List %a = %{ .Nil | .Cons %a (%List %a) }`

型式内の記号:
- `%a` 等は型変数。
- `.Tag` はコンストラクタラベル（値レベルと同ラベル空間でも可）。
- `%Name %args...` は型名の適用。

## 自己参照→μ 変換（“同形”規則）
- 対象: 宣言 RHS 内の、LHS ヘッド名の再出現のうち “同形” なもの。
- “同形”の定義:
  - LHS の型変数列と同一順・同一変数集合の適用（α変換のみ許容）。
  - 例: `%List %a` の RHS 中の `%List %a` は同形。`%List (%Foo %a)` や部分適用は同形でない。
- 変換手順:
  1) 新鮮な束縛型変数 `%T` を導入。
  2) RHS 中の同形な自己参照 `%Head %params` を `%T` に一括置換。
  3) 内部表現を `μ %T . Body` とする（Body は sum/record/tuple 等）。
- 例（List）:
  - 入力: `%List %a = %{ .Nil | .Cons %a (%List %a) }`
  - 内部: `μ %T . sum { .Nil | .Cons %a %T }`

Option は μ 不要:
- 入力: `%Option %a = %{ .Some %a | .None }`
- 内部: `sum { .Some %a | .None }`

## スコープ
- LHS 引数（%a 等）: その宣言の RHS 内のみ有効。
- 自己束縛 `%T`: 内部変換で導入されるローカル束縛（外部から参照不可）。
- LHS ヘッド名（%List 等）: 型名前空間に束縛。相互再帰グループ内で相互可視、グループ外にもエクスポート。

## 相互再帰グループ
- 連続した `%` 宣言列を 1 グループとみなし、2 パス処理。
  - パス1: 各宣言のヘッド名とアリティを登録。
  - パス2: 各 RHS で“同形自己参照→%T→μ”変換を実施。他型名参照は Named のまま。
- 相互再帰は許可（A から B、B から A を参照可）。自己参照のみ `%T` に置換。

## 健全性チェック
- 正位置（positivity）: `μ %T . Body` において `%T` は正位置のみ。
  - 許可: sum/record/list/tuple の要素位置（共変）。
  - 禁止: 関数の引数位置など負位置。
- 同形制約: 自己参照は“同形”でなければならない。
- 展開停止性: μ 展開は on-demand で 1 段。Visited セット/燃料で発散防止。

## ユニファイ戦略（isorecursive）
- `unify(μ %T . A, B)`:
  - 必要に応じて `A[%T := μ %T . A]` を 1 回だけ展開して B と比較（逆も同様）。
- occurs check:
  - 通常の型変数に対して実施。`%T` は束縛子なので対象外。
  - 変数 vs μ の場合は、μを 1 段剥がしてから判定する優先度を採用。

## 既存との整合（移行）
- 既知ファミリの正規化:
  - 表示/注釈では `%List %a` / `%Option %a` を優先表示。
  - 内部は既存の構造（List 型/ SumCtor）と相互変換可能にする（移行期）。
- Prelude/既存コードは互換維持。型注釈で型名を使えるようにして読みやすさ向上。

## 実装スライス（段階導入）
1. パーサ
   - `%` 型宣言を追加（ヘッド名、型変数列、RHS 型式）。
   - 型式に `Mu(T, Body)` と `Named(name, args)` を追加。
2. 型定義環境
   - `TypeDefEnv`: name → (params, body)。
   - 2 パス登録＋“同形自己参照→μ” 変換。
3. 型表現/ユニファイ
   - μ の 1 段展開ユニファイ、positivity チェック、visited 管理。
   - Named の on-demand 展開（完全展開せず比較必要箇所のみ）。
4. 表示/エラー
   - 既知ファミリは型名で表示。構造一致時に Named へ寄せる。
   - occurs/positivity 失敗にはスパン付きの分かりやすい診断。
5. 橋渡し
   - 既存 List/Option/Bool と相互運用。最初は内部表現を併存、後に統一を検討。

## オープン事項（要合意）
- グルーピングの決め方（ファイル/空行/ブロック）
- ラベル空間（.Tag）の共有方針（現状どおりでよい見込み）
- Named の等価性：完全展開の構造同値ベースで運用（名義同値は導入しない）
- positivity チェックの厳密度（関数型の負位置のみ禁止で開始）

## 参考スニペット
- Option:
  - ソース: `%Option %a = %{ .Some %a | .None }`
  - 内部: `sum { .Some %a | .None }`
- List:
  - ソース: `%List %a = %{ .Nil | .Cons %a (%List %a) }`
  - 内部: `μ %T . sum { .Nil | .Cons %a %T }`

---
この仕様で進める場合、まずはパーサと型定義環境の導入（段階 1-2）から着手します。実装後は、`~map`, `~length` などの代表関数で型注釈とユニファイ挙動を検証します。

  ## Let 式への統合（型宣言グルーピングとスコープ）

  Let 式に型宣言（%）を組み込む。構文は次のように拡張する。

  - 旧: `letExpr ::= bind* body bind*`（ただし前後の bind は 1 つ以上）
  - 新: `letExpr ::= (bind | typedeclare)* body (bind | typedeclare)*`

  ここで `typedeclare` は本ドキュメントの `%TypeName %a ... = %{ ... }` を指す。

  スコープ/解決規則:
  - Let ブロック内の連続した `(bind | typedeclare)` 列を 1 グループとみなし、値名空間と型名空間をそれぞれ相互再帰として処理する。
  - 2 パス処理（型名空間）:
    1) パス1: `%TypeName` とアリティの登録（シャドウ可能）。
    2) パス2: RHS を“同形自己参照→%T→μ”変換して `TypeDefEnv` に確定登録。
  - 値の `bind` から `typedeclare` を参照可能（同一 Let グループ内であれば可）。
  - `typedeclare` から外側の型名も参照可能（通常の静的スコープ）。
  - LHS の型変数（%a 等）は宣言 RHS 内にだけ有効。自己束縛 `%T` は内部のみ。

  例（Let 内での相互参照）:
  ```
  let
    %List %a = %{ .Nil | .Cons %a (%List %a) }
    ~length = \(~xs) ->
      \[] -> 0
    | \[ ~_ : ~t ] -> 1 + (~length ~t)
  in
    ~length [1,2,3]
  ```
  この例では、`%List` は Let グループ内に束縛され、`~length` から参照できる。`%List` はグループの外へもエクスポートされる。
