## lzscr 言語概要と開発環境選定

本ドキュメントは、GitHub: mako10k/lazyscript を下敷きにした焼き直し計画のための要点整理です。

### 1) 言語の要点（原版 lazyScript から抽出）

- 目的: 遅延評価を中核とした実験的スクリプト言語。式ベースで、トップレベルは `prog ::= expr ';'`。
- 値・実行時概念（代表）:
	- thunk による遅延評価。主な種別: lambda, appl, ref, int, str, builtin, alge（タプル/データ的包）、choice、bottom（エラー相当）。
	- 参照: `~name` で評価時に束縛を解決。
	- ラムダ: `\x -> expr`。ブロック `{ expr }` は式。
	- リスト/タプル: リテラル・コンス `:` などを糖衣/デシュガで表現。
	- 裸シンボル: これまでの「alge の頭」から拡張し、同名の「コンストラクタ変数」（型から型への写像）として扱う（詳細は章 10）。
	  - ゼロ引数のコンストラクタは必ず `S()` で記述（素の `S` は変数束縛/参照と解釈）。
- シンタックスシュガー（現在の既定ルートモジュールは `prelude`）:
	- `~~sym` → `(~prelude sym)`（純粋 API の短縮）
	- `!sym` → `(~prelude .env .sym)`（効果 API の短縮。例: `!println`, `!require`, `!def`）
	- `!{ ... }` → `chain/bind/return` への展開（do 記法相当）。
	- ルートモジュールは CLI/環境変数で切替可能（互換のため当面は `--sugar-namespace` を使用）。
 	- 例外系糖衣: `^(Expr)` は Bottom を投げる（raise）。`Expr ^| <lamchain>` は左からの Bottom を捕捉（caret パターンで束縛）。
- 実行セマンティクス:
	- ファイル実行は既定で `main` 関数を探して実行（`--entry` で変更可）。
	- `-e` で 1 行式を評価し最終値を出力（`main` は無視）。
	- strict-effects: 効果を持つビルトイン（println/print/def/require 等）は `seq/chain/bind` の文脈に制限。
- ビルトイン/プレリュード:
	- コア: `to_str, print, println, seq, add, sub, lt, eq, chain, bind, return` 等。
	- プレリュードはプラグイン（.so）で差し替え可能。`ls_prelude_register` により `prelude` モジュールを提供。
	- 実行時拡張: `~~require "path.ls"`, `~~def Name value` 等で動的ロード/定義。
- 中間表現:
	- Core IR を生成/実行する経路あり（最小タイプチェック、将来 LLVM IR 降ろし）。
- ツール:
	- フォーマッタ、VS Code 機能拡張（構文ハイライト/フォーマット/診断）。

### 2) 焼き直しの方針と選定

選定: 実装言語は Rust（stable）を採用。

主な理由:
- 安全性/安定性: 所有権と型でメモリ安全・未定義動作を抑止。C 実装の GC 依存を脱却。
- パーサ/診断体験: `chumsky`/`lalrpop`/`logos` + `ariadne`/`miette` による高品質エラーメッセージ。
- プラグイン/FFI: `libloading` 経由で `cdylib` プラグイン（プレリュード）をロード可能。
- 将来の IR/LLVM: `inkwell` により LLVM IR 出力への道筋が明確。
- 配布性/開発速度: Cargo による依存/ビルド管理、単一バイナリ配布、クロスプラットフォーム性。

比較メモ:
- C(+Flex/Bison): 原版踏襲で移植は容易だが、安全性/開発体験で Rust に劣る。
- Zig: 単一バイナリや FFI は良いが、エコシステム/パーサまわりの成熟度で Rust 優位。
- OCaml: 言語処理系向きだが配布/FFI/周辺の導入障壁を考慮して今回は見送り。

### 3) 提案アーキテクチャ（Cargo Workspace）

推奨ワークスペース構成（例）:
- crates/
	- lzscr-lexer: logos ベースの字句解析。
	- lzscr-ast: AST と位置情報、表示/フォーマット補助。
	- lzscr-parser: chumsky で構文解析 + デシュガ（`~~`, `!`, `!{}`）。
	- lzscr-runtime: thunk/環境/評価器、効果規律（strict-effects）検証。
	- lzscr-coreir: Core IR 定義・ロワリング・最小タイプチェック。
	- lzscr-llvmir (opt): inkwell による LLVM IR 出力（後段）。
	- lzscr-cli: `lzscr` 本体（-e, --strict-effects, --entry 等の互換 CLI）。
	- lzscr-compiler (opt): `lzscrc`（Core IR 出力/型検証）。
	- lzscr-prelude: `cdylib` プラグイン（`ls_prelude_register()` を C-ABI で公開）。
	- lzscr-format: フォーマッタ（AST -> 再整形）。

設計ノート:
- メモリ/所有権: 遅延評価の循環参照は arena/slotmap で ID 管理し、`Rc`+`RefCell` の循環は許容/リークなし方針。
- 効果規律: ランタイムで `seq/chain/bind` の文脈を追跡し、効果ビルトイン呼出を検証。
- プラグイン ABI: `#[no_mangle] extern "C" fn ls_prelude_register(env: *mut Env) -> i32`（原版互換）を想定。`libloading` で動的解決。

補足（原版との差分の明示）:
- List 構文を実装済み: リストリテラル `[a, b, ...]`、空リスト `[]`、cons 演算子 `h : t`（右結合）。
	- デシュガ: `h : t` → `((~cons h) t)`、`[a,b,c]` → `(~cons a (~cons b (~cons c [])))`。
	- `cons : a -> List a -> List a` はビルトイン関数。

### 1.1) 用語の整理（名称の変更）

- 名前空間（namespace）: コンパイル時の名前解決ドメイン（レキシカル/モジュール/インポートの集合）。識別子→スロット/インデックスへの静的リンクを担う概念。
- モジュール（module）: 実行時の辞書的コンテナ（値）。`(~prelude sym)` や `(~prelude .env .println)` のような値レベルのメンバアクセスはモジュールアクセス。
- 環境（environment）: 評価時の実行環境（フレーム/クロージャ捕捉を含む）。

備考: 互換のため CLI のオプション名 `--sugar-namespace` は当面維持しますが、文書上は「ルートモジュール」と表記します。

### 4) 開発環境セットアップ（推奨）

- ツールチェーン: Rust stable（rustup）、rustfmt、clippy。
- エディタ: VS Code + rust-analyzer（推奨設定: 保存時フォーマット/Clippy 警告表示）。
- CI: GitHub Actions（build + test + clippy）。
- 追加（将来の LLVM 機能用）: LLVM 15+ と `inkwell`（オプション）。
- テスト: `cargo test`（パーサのゴールデンテスト、評価器の期待出力テスト、プロパティテストに `proptest`）。

拡張子/MIME:
- 公式拡張子: `.lzscr`
- MIME: `text/vnd.lzscr; charset=utf-8`
- 当面のエディタ関連付け: VS Code は `*.lzscr` を `plaintext` に関連付け（`.vscode/settings.json`）。将来的に専用拡張でシンタックスハイライト/言語機能を提供予定。

#### 4.1) CLI/ENV 互換方針（初期 + 将来）

- 初期にサポート: `-e/--eval`, `-s/--strict-effects`, `--entry`, `-p/--prelude-so`, `-n/--sugar-namespace`。
- 環境変数: `LAZYSCRIPT_PRELUDE_SO`, `LAZYSCRIPT_SUGAR_NS`, `LAZYSCRIPT_INIT` は CLI と等価に扱う。
- 将来対応（拡張）: `-i/--dump-coreir`, `-c/--eval-coreir`, `-t/--typecheck`, `--no-kind-warn`, `--kind-error`, `--init`, `--trace-map`, `--trace-stack-depth`, `-d/--debug`, `-v/--version`。
	- 将来、別名 `--sugar-module` を追加し、`--sugar-namespace` は非推奨化（互換維持）を検討。

### 5) 当面のマイルストーン

1. ワークスペース雛形の作成（crates 配置、最小 CLI: `-e` と `--strict-effects`）。
2. 字句/構文/デシュガの実装（コメント/数値/文字列/参照/ラムダ/ブロック/cons ほか）。
3. 最小評価器（int/str/lambda/appl/ref）とコア純粋ビルトイン（`to_str`, `add/sub/eq/lt`）。
4. 効果 API の導入（`println/print/def/require`）と strict-effects 検証。
5. プレリュード `cdylib` の設計と動的ロード互換（`--prelude-so`）。
6. フォーマッタ/VS Code 連携の基礎（拡張は後続）。
7. Core IR の導入と最小タイプチェッカ、将来の LLVM 連携土台作り。

### 6) 束縛解決戦略（できる限り早期リンク）

目的: 参照（`~name` や糖衣展開後の名前）を実行時ではなくコンパイル時（IR 生成時）に可能な限り位置参照へ解決し、ランタイムの名前探索を最小化する。

設計方針（要約）:
- 二相処理: 1) 名前解決（スコープ/束縛の収集と参照解決）→ 2) パターンの実行時代入を含む IR 生成。
- 参照種別:
	- ローカル束縛: de Bruijn インデックスまたは連番スロットに静的解決（関数引数・`let`/`bind` の LHS 名）。
	- クロージャ捕捉: upvalue テーブル（親フレームのスロット参照）に静的解決。
	- モジュール（トップレベル）束縛: モジュール内シンボル表の固定スロットに解決（相互再帰を許す）。
	- モジュールアクセス（`(~mod name)`）: `mod` 自体への参照は静的スロット化、メンバは「未知可変境界」として遅延（プラグイン/実行時 import に対応）。
	- 動的環境操作（`!require`, `!def` 等）: 遅延境界。これらが導入する名前は静的解決の対象外とし、明示的に「動的アクセス」ノードで扱う。

パターン束縛の扱い:
- LHS パターンに現れる識別子は「スコープに宣言された静的スロット」を即時確保し、RHS 評価後のパターン実行で「そのスロットに代入」する。
- したがって、RHS 内の該当識別子参照は「静的にそのスロットを指す」ことが可能（ただしパターンの評価順序上、未束縛使用があれば別途検出）。
- 失敗時（パターン不一致）は Bottom を生成し、上位に伝播（`^|` で捕捉可能）。

トップレベル（モジュール）束縛:
- 1 パス目で宣言名をすべて収集しスロット割当（相互再帰を許可）。
- 2 パス目で各式/関数本体の参照を解決。初期化は実行時に thunk として遅延可能。

IR への落とし方（最小案）:
- VarRef(kind, slot, upvalue_path) で識別子参照を表現（文字列を持たない）。
- PatBind: 実行時オペコードで、マッチ成功時に「事前確保されたスロット」へ代入。
- ModuleRef(mod_slot) + DynMember(".env"/name) でモジュールの動的境界を明確化。

エラー検出（名前解決段階）:
- 未束縛参照（lexical/global）を静的にエラー化。
- パターン LHS の重複名/隠蔽の衝突検出。
- 使用前参照（初期化前使用）: 依存グラフで自己参照の不正なパスを検知（関数定義は許可、値定義の即時自己参照はエラー）。

例外系糖衣との整合:
- `^(Expr)` は IR で Raise(Expr) とし、`^|` は TryCatchCaret(chain) に降ろす。名前解決済みの参照を含むため、捕捉側の caret パターンも静的スロット確保→実行時代入の流れ。

互換ポリシー:
- 既存の `~~sym`/`!sym`/`!{}` はパーサ段階でデシュガ→名前解決フェーズへ。
- プレリュードのシンボルは「モジュールスロット + 動的メンバ」扱いにしてプラグイン差替えへ対応。

実装ステップ（短期）:
1) スコープ/シンボル表の導入（モジュール/ラムダ単位）。
2) LHS パターンの宣言スキャン→スロット予約→RHS/本体内参照の静的解決。
3) パターンコンパイル（実行時代入）とエラー伝播の IR 化。
4) upvalue 解析とクロージャのキャプチャ表構築。

品質ゲート:
- 単体: 参照解決テスト（シャドーイング/相互再帰/パターン束縛）
- プロパティ: α変換不変性（名前の置換で意味不変）
- レグレッション: require/def の動的導入は静的解決の対象外であることの確認

### 7) 開発Tips（bash の `!` ヒストリ展開）

`-e` で `!{ ... }` を渡す際、bash のヒストリ展開に注意。
- 推奨: 外側で `set +H` を有効化、もしくは単引用符/ヒアドキュメントを使う。
- 例: `( set +H; ./target/debug/lzscr -e '!{ !println ("ok"); };' )`

### 8) 将来対応（拡張）

- Core IR ダンプ/実行、最小タイプチェック、Kind 警告/エラー、実行トレース（sourcemap/stack 深さ）等の CLI オプション追加。

### 9) 型システム（MVP）

目的: 実行前に可能な範囲で型・効果の誤りを検出し、実装の安全性とエラーメッセージ品質を高める。

方針（最小）:
- 種別（Kind）と型（Type）を分離。
	- Kind: `Pure` | `IO`（効果あり）。式やビルトインに付く分類。既存の strict-effects 規律と整合。
	- Type: HM 風の単相/多相型（ランク1）。`Int`, `Str`, `Unit`, `Tuple[t1,...,tn]`, `List[t]`, `Func[t1 -> t2]`。
- 型注釈は当面なし（将来 `x : T` を導入可）。ビルトインとプリミティブに十分なシグネチャを付与。
- 名前解決後の IR 上で型推論（アルゴリズム W）と Kind 検証を行う。

代表的な型規則（概要）:
- 参照: 解決済みスロットに付与された型変数/スキームをインスタンス化。
- ラムダ: 引数に新鮮な型変数 α を割当て、`body` の型 β を推論し `α -> β`。
- 適用: `f : α -> β`, `x : α` を要求して β を得る（単一化）。
- タプル/リスト: 要素型をそれぞれ推論し構成（リストは同一要素型）。
- パターン束縛: 右辺の型に基づき LHS パターンへ制約を付与し、各変数に型を割当てる（タプル分解等）。
- raise/catch:
	- `^(e)` は「任意型 ρ」を返せるが Bottom を導入。`e` の型はペイロード型 γ とし、`^|` の caret パターンは γ を受ける。
	- `x ^| handler` は `x` と `handler` の戻り型が一致すること。

Kind 規律（最小）:
- `IO` Kind の値/関数は、`chain/seq/bind` の文脈内でのみ評価を許可。`Pure` はどこでも可。
- ビルトインに Kind 注釈を付与し、型検査時に違反を報告（CLI: `--no-kind-warn`/`--kind-error` に対応）。

主なビルトインの型/Kind（例）:
- `to_str : forall a. a -> Str`（Pure）
- `add, sub : Int -> Int -> Int`（Pure）
- `eq : forall a. a -> a -> Bool`（Pure）
- `lt : Int -> Int -> Bool`（Pure）
- `print : Str -> Unit`（IO）
- `println : Str -> Unit`（IO）
- `return : forall a. a -> a`（Pure）
- `seq : a -> b -> b`（Pure、ただし第二引数側の Kind が IO の場合は文脈検証で許可）
- `chain : m -> (Unit -> k) -> k`（文脈的: 実装では Kind 検証で取り扱う）
- `bind : m -> (x -> k) -> k`（同上）

注: `Bool` は lzscr で導入（原版は明示的な Bool 型の代わりに代数的表現を取ることがあった）。既存テスト移行時は真偽値表現をマッピングする。

#### 9.1) Bool の設計（提案/合意）

- Bool は「タグ `.false` | `.true` を受け取って Bool 値を返す」1 引数コンストラクタ関数として定義する。
	- 型: `Bool : (.false | .true) -> Bool`
	- 例: `Bool .true` は真、`Bool .false` は偽。
- 実用上の書き方として、以下の等価関係を採用:
	- `true = Bool .true`、`false = Bool .false`
	- ゼロ引数コンストラクタの規約に従い、`true()`/`false()` と書ける（`()` は Unit を表す慣習的プレースホルダ）。

備考（PoC 現状との整合）:
- 現在の実装では簡便のため `~true`/`~false` が直接 Bool 値を参照として提供される。
	- 追加済みの糖衣: `true()`/`false()` は `~true`/`~false` に展開される。
	- 追加済みのコンストラクタ: `(~Bool .true)` / `(~Bool .false)` が Bool 値を返す。
	- 将来、`~true`/`~false` を非推奨化（互換期は両対応）を検討。

エラーの種類（例）:
- 型不一致/単一化失敗、未解決型変数の漏れ（総称化漏れ）、リスト要素型の不一致。
- 関数適用の多寡（arity）不一致。
- Kind 規律違反（`println` を `chain/seq/bind` 外で使用）。

検証と実装ノート:
- IR 上での型推論（アルゴリズム W）実装と制約ソルバ（発見的に発生順で単一化）。
- let-多相: トップレベル/`let` 的束縛で一般化、利用時にインスタンス化。
- パターン束縛は RHS 推論後に制約適用→スロットへ型割当て。
- 例外（Bottom）を伴う経路は型は維持しつつ、別途「Bottom 到達可能」フラグを保持（将来のデッドコード警告用途）。

テスト計画（最小）:
- 単体: 算術/比較/文字列連結、ラムダ/適用、タプル/リスト、パターン分解の型付け。
- Kind: `println` の許可/拒否ケース、`chain/seq/bind` 文脈の境界。
- 回帰: 相互再帰関数、未束縛名、raise/catch の型整合。

### 10) コンストラクタ変数（裸シンボルの再解釈）

目的: 裸シンボルを「コンストラクタ変数」として扱い、同名出現間で型の互換性を静的に管理しつつ、パターン/値両方で統一的に利用できるようにする。

直観:
- `Foo` は初出時に「型から型への写像」として導入される。語義上は型コンストラクタ（kind `* -> *`、多引数は `*^n -> *` としてタプル化）に相当。
- 値レベルではコンストラクタ関数として振る舞い、`Foo a b` のように適用すると payload 型が `(type(a), type(b))` のタプルになる。
- パターン `Foo x y` は scrutinee の型が `Ctor<'Foo, (tx, ty)>` であることを要求し、`x:tx`, `y:ty` を束縛する。

型表現（MVP 案）:
- 新しい型コンストラクタ `Ctor<'Sym, P>` を導入（`'Sym` はスコープ内で一意なタグ、`P` は payload 型）。
- 裸シンボル `S` の主型は「アリティ n を持つカリー化関数」として扱う。初回に「完全適用」された使用が現れた時点でアリティ n を確定し、
	主型は `forall a1..an. a1 -> ... -> an -> Ctor<'S, (a1,..,an)>` となる（payload は n-タプル）。
- 多引数の値構築は `S a b c` のように通常の関数適用で表現でき、部分適用も許可される（例: `S a : forall b c. b -> c -> Ctor<'S,(type(a),b,c)>`）。
 - n=0（ゼロ引数）の場合、payload は `Unit` とし、必ず `S()` で構築・パターン記述する（素の `S` は変数として解釈）。

Bool への適用例:
- `Bool` は 1 引数のコンストラクタで、payload はタグ `.true`/`.false` のいずれか。
- 便宜上のシノニム: `true = Bool .true`, `false = Bool .false`。ゼロ引数コンストラクタ規約に則り `true()`/`false()` と記述する。

推論/互換性（相互チェック）:
- 同一スコープ内の同名 `S` の出現は、payload 形状が単一化可能であることが必要（例: `S Int` と `S Str` は矛盾→エラー）。
- 形状が整合する場合、最汎一般単一化（MGU）で payload の型変数が絞り込まれ、「より厳しい型」への強化を実現。
- let-多相により、`S` 自体のスキームは `forall P` を保つ（各使用点でインスタンス化）。ただし、スコープ内で矛盾する使用があると検出される。

アリティ確定と曖昧性:
- 少なくとも 1 か所、完全適用の使用が同一スコープ（SCC）内に必要。これがない場合、`S` のアリティが決められず曖昧性エラーを報告（将来は型注釈で解消可能）。
- 複数の完全適用が存在し、異なる引数個数を要求する場合はエラー（`S a b` と `S x` が同スコープに混在など）。
 - 0 引数のコンストラクタは常に `S()` を要求（式/パターン双方）。`S` 単体の出現はコンストラクタと見なさない。

スコープ:
- 通常変数と同様にレキシカルスコープ。トップレベルでの初出はモジュール内で有効。
- シャドーイングは可能だが、可読性のため警告（将来のリンタ対象）。
- モジュール間で同名でも別タグ。インポートで同一視する場合は別名束縛（alias）で統合。

動的導入との関係:
- `!def`/`!require` によって実行時に導入される名前は、コンストラクタ変数としては扱わない（静的解決対象外）。
- コンストラクタ変数は静的解析で導入された裸シンボルに限定し、ダイナミックな上書き/導入はエラーまたは警告とする（リンタ/オプションで制御）。

パターンとの整合:
- パターン側の `S` も同じタグ `'S` を参照。スコープに未登録なら初出として導入され、以降の出現と単一化される。
- パターン中での arity/形状不一致（例: `S x` と `S (x,y)` が混在）はエラー。
 - 0 引数のパターンは `S()` のみ許可（`S` は変数束縛）。

IR 影響:
- 既存の alge 実装を流用し、タグに `'S` の ID を割当て、payload を格納（実行時表現は従来と同等）。
- `S` は「カリー化されたコンストラクタビルトイン」として実装可能（部分適用はクロージャで引数を蓄積し、飽和時に alge を構築）。
- 型検査器のみ `Ctor<'S,P>` を理解し、`S` の出現間の単一化を行う。

エラー例:
- `S 1` と `S "x"` の混在（同スコープ）→ payload 型 `Int` と `Str` の単一化失敗。
- `match v with S x -> ... | S (x,y) -> ...`（同スコープ）→ 形状不一致。

備考（実務上の注意）:
- 暗黙宣言（初出で導入）はタイポを招きやすい。将来、`--warn-implicit-ctor` などで警告/禁止を切替可能にする。
- 将来的に ADT 宣言やエクスポートを導入する場合は、この「暗黙コンストラクタ変数」を表明/固定化する構文を追加する。

---

決定事項: 再実装は Rust（Cargo workspace）で進める。CLI 互換性とプレリュード・プラグイン機構は維持しつつ、診断品質と安全性を向上させる。

## 構文と名前解決（再確認と暫定実装メモ）

- 識別子: 仕様通り「前置記号なしの裸の識別子はコンストラクタ変数」。
- 参照: 実体（値）への参照は `~name`。ビルトイン呼び出しは `(~add 1 2)` のように書く。
- 0 引数コンストラクタ: あいまいさ回避のため `S()` を必須とする。

補足（現状仕様の要点）:
- 中値演算子: `+ - * /`（Int）、`.+ .- .* ./`（Float）、比較 `< <= > >=` と `== !=`、Float 比較は `. < .<= .> .>=`。
	- OrElse 演算子は `||`（従来の `|` から移行済み）。パーサ/整形出力も `||` を使用。
	- 代替ラムダ合成演算子 `|` を導入。
		- 構文制約: 左右オペランドはいずれもラムダ（`\pat -> body`）でなければならない（右結合。ネストされた `|` は可）。
		- 優先順位: `->`（ラムダ矢印）より低い、`||` よりも低い。すなわち `\p -> e1 | \q -> e2` は `(\p -> e1) | (\q -> e2)` と解釈される。
		- 意味論: 適用時に「左ラムダのパターン照合が失敗した場合のみ」右ラムダを試す。左がマッチした後に本体でエラーになっても右は評価しない。
		- デシュガ（実装内部）: `\x -> (~alt left right x)` に展開。`alt : (a->r) -> (a->r) -> a -> r` はランタイムのビルトイン。
		- 例:
			- `((\[~h:~t] -> ~h) | (\[] -> 0)) xs` は、空でなければ先頭、空なら 0。
- タプル/レコード糖衣: `(a,b,...)` → `(.Tuple a b ...)`、`{k:v,...}` → `(.Record (.KV "k" v) ...)`。
	- レコードのキーは識別子（ident）のみ許可。`{a:1, b:2}` は可だが、`{"a":1}` のような文字列キーは不可。
	- フィールドアクセスは「レコードを関数としてシンボルで呼び出す」方式のみ: `{a:1, b:2} .a`。文字列キーでのアクセス（例: `{a:1} "a"`）は非対応。
- Bool: `true()`/`false()` は `~true`/`~false` に展開。`(~Bool .true)`/`(~Bool .false)` でも構築可能。
- Ctor アリティ: CLI で `--ctor-arity 'Foo=2,Bar=0'` のように宣言。実行時の誤用をエラー化、`--analyze` と併用で静的検出（over/zero-arity-applied）も可。

CLI 例:

```
# 解析（テキスト）
cargo run -p lzscr-cli -- -e '.Foo 1 2' --analyze --ctor-arity 'Foo=1'

# 解析（JSON）
cargo run -p lzscr-cli -- -e '.Foo 1 2' --analyze --format json --ctor-arity 'Foo=1'

# 実行時エラー例（過剰適用）
cargo run -p lzscr-cli -- -e '.Bar 1 2' --ctor-arity 'Bar=1'
```

暫定実装の挙動:
- パーサ: `Ident` は `Symbol`（コンストラクタ変数）として AST 化し、`~Ident` は `Ref`。
- 評価器: `Symbol` は適用されたときに引数列を蓄積する未解決構成値として扱い、将来の型/解決段で具体化する。現段階では `S()`, `S a`, `S a b` などは値として構築途中の `<fun>` 表示になる（意味付けは型/IR 実装後に確定）。
- ビルトイン: 参照によって解決されるため `~` が必要。例: `(~to_str (~add 1 2))`。

