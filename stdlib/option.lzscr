# stdlib: Option module
# Provides functional helpers around .Some/.None option-like constructors.

# Predicates
~is_some = \(.Some _) -> ~true | \.None -> ~false;
~is_none = \(.Some _) -> ~false | \.None -> ~true;

# map (f : a -> b) : Option a -> Option b
~map ~f = \(.Some ~x) -> .Some (~f ~x) | \.None -> .None;

# and_then / flat_map
~and_then ~f = \(.Some ~x) -> (~f ~x) | \.None -> .None;

# or_else : Option a -> (Unit -> Option a) -> Option a (lazy alt)
# Implemented by passing a thunk lambda with unit param
~or_else ~th = \(.Some ~x) -> .Some ~x | \.None -> (~th ());

# unwrap_or : Option a -> a -> a  (default eager)
~unwrap_or ~def = \(.Some ~x) -> ~x | \.None -> ~def;

# unwrap_or_else : Option a -> (Unit -> a) -> a (lazy default)
~unwrap_or_else ~th = \(.Some ~x) -> ~x | \.None -> (~th ());

# to_list : Option a -> List a
~to_list = \(.Some ~x) -> (~cons ~x []) | \.None -> [];

# from_bool : Bool -> a -> Option a (true => Some a)
~from_bool ~b ~x = (~if ~b (.Some ~x) .None);

# maybe : b -> (a -> b) -> Option a -> b
~maybe ~def ~f = \(.Some ~x) -> (~f ~x) | \.None -> ~def;

# contains : (Eq) a => a -> Option a -> Bool
~contains ~needle = \(.Some ~x) -> (~x == ~needle) | \.None -> ~false;

{
  is_some: ~is_some,
  is_none: ~is_none,
  map: ~map,
  and_then: ~and_then,
  or_else: ~or_else,
  unwrap_or: ~unwrap_or,
  unwrap_or_else: ~unwrap_or_else,
  to_list: ~to_list,
  from_bool: ~from_bool,
  maybe: ~maybe,
  contains: ~contains
}
