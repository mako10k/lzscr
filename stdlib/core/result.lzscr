# stdlib/core/result.lzscr
# Result type for error handling
# Constructors: Ok x | Err e
# Type definition (for documentation)
%Result ~a ~e      = %{Ok ~a | Err ~e};
# Predicates
~is_ok             = \(Ok _) -> True | \(Err _) -> False;
~is_err            = \(Ok _) -> False | \(Err _) -> True;
# map : (a -> b) -> Result a e -> Result b e
~map ~f            = \(Ok ~x) -> Ok (~f ~x) | \(Err ~e) -> Err ~e;
# map_err : (e1 -> e2) -> Result a e1 -> Result a e2
~map_err ~f        = \(Ok ~x) -> Ok ~x | \(Err ~e) -> Err (~f ~e);
# and_then : (a -> Result b e) -> Result a e -> Result b e
~and_then ~f       = \(Ok ~x) -> (~f ~x) | \(Err ~e) -> Err ~e;
# or_else : (e -> Result a f) -> Result a e -> Result a f
~or_else ~f        = \(Ok ~x) -> Ok ~x | \(Err ~e) -> (~f ~e);
# unwrap_or : a -> Result a e -> a
~unwrap_or ~def    = \(Ok ~x) -> ~x | \(Err ~_) -> ~def;
# unwrap_or_else : (e -> a) -> Result a e -> a
~unwrap_or_else ~f = \(Ok ~x) -> ~x | \(Err ~e) -> (~f ~e);
# to_option : Result a e -> Option a
~to_option         = \(Ok ~x) -> Some ~x | \(Err _) -> None;
# from_option : e -> Option a -> Result a e
~from_option ~err  = \(Some ~x) -> Ok ~x | \_ -> Err ~err;
# transpose_option : Result (Option a) e -> Option (Result a e)
~transpose_option  = (\(Ok ~opt) -> (((\(Some ~x) -> Some (Ok ~x)) | \_ -> None) ~opt) | \(Err ~e) -> 
  Some (Err ~e)
);
# flatten : Result (Result a e) e -> Result a e
~flatten           = \(Ok ~inner) -> ~inner | \(Err ~e) -> Err ~e;
{
  is_ok           : ~is_ok,
  is_err          : ~is_err,
  map             : ~map,
  map_err         : ~map_err,
  and_then        : ~and_then,
  or_else         : ~or_else,
  unwrap_or       : ~unwrap_or,
  unwrap_or_else  : ~unwrap_or_else,
  to_option       : ~to_option,
  from_option     : ~from_option,
  transpose_option: ~transpose_option,
  flatten         : ~flatten
}
