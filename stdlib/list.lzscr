# stdlib: List extra utilities built atop core prelude (~cons, ~foldl, etc.)

# any : (a -> Bool) -> [a] -> Bool
~any ~p ~xs = (\[] -> .False | \( ~h : ~t ) -> (~if (~p ~h) .True (~any ~p ~t))) ~xs;

# all : (a -> Bool) -> [a] -> Bool
~all ~p ~xs = (\[] -> .True | \( ~h : ~t ) -> (~if (~p ~h) (~all ~p ~t) .False)) ~xs;

# sum : [Int] -> Int
~sum ~xs = (~foldl (\~acc ~x -> (~acc + ~x)) 0 ~xs);

# product : [Int] -> Int
~product ~xs = (~foldl (\~acc ~x -> (~acc * ~x)) 1 ~xs);

# head : [a] -> Option a
~head ~xs = (\[] -> .None | \( ~h : ~_ ) -> .Some ~h) ~xs;

# tail : [a] -> Option [a]
~tail ~xs = (\[] -> .None | \( _ : ~t ) -> .Some ~t) ~xs;

# take_while : (a -> Bool) -> [a] -> [a]
~take_while ~p ~xs = (\[] -> [] | \( ~h : ~t ) -> (~if (~p ~h) (~cons ~h (~take_while ~p ~t)) [])) ~xs;

# drop_while : (a -> Bool) -> [a] -> [a]
~drop_while ~p ~xs = (\[] -> [] | \( ~h : ~t ) -> (~if (~p ~h) (~drop_while ~p ~t) (~cons ~h ~t))) ~xs;

# concat : [[a]] -> [a]
~concat ~xss = (~foldr (\~xs ~acc -> (~foldr (~cons) ~acc ~xs)) [] ~xss);

# flat_map : (a -> [b]) -> [a] -> [b]
~flat_map ~f ~xs = (~concat (~map ~f ~xs));

# zip_with : (a -> b -> c) -> [a] -> [b] -> [c]
~zip_with ~f ~xs ~ys = (
  ~go ~as ~bs = (\[] -> [] | \( ~ha : ~ta ) -> (
    (\[] -> [] | \( ~hb : ~tb ) -> (~cons (~f ~ha ~hb) (~go ~ta ~tb))) ~bs
  )) ~as;
  ~go ~xs ~ys
);

# zip : [a] -> [b] -> [(a,b)]
~zip ~xs ~ys = (~zip_with (\~a ~b -> (~a, ~b)) ~xs ~ys);

# intersperse : a -> [a] -> [a]
~intersperse ~sep ~xs = (
  ~go ~list = (\[] -> [] | \( ~h : ~t ) -> (
    (\[] -> (~cons ~h [])) | (\_ -> (~cons ~h (~cons ~sep (~go ~t))))
  ) ~t) ~list;
  ~go ~xs
);

{
  any: ~any,
  all: ~all,
  sum: ~sum,
  product: ~product,
  head: ~head,
  tail: ~tail,
  take_while: ~take_while,
  drop_while: ~drop_while,
  concat: ~concat,
  flat_map: ~flat_map,
  zip_with: ~zip_with,
  zip: ~zip,
  intersperse: ~intersperse
}
