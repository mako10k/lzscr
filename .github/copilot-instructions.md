# Copilot Instructions

<!-- Auto-generated by mcp-copilot-instructions -->
<!-- Mode: normal -->
<!-- Context: phase=refactoring, focus=Error Display, Phase 5 Record Field Spans, TypeError diagnostics, Step 9 -->
<!-- Generated: 2025-12-03T09:21:59.759Z -->
<!-- Stats: 0 required, 2 optional (3 filtered) -->

## meta: Tool Usage Guide

This MCP server handles external storage and dynamic generation of instructions. Use the following tools appropriately.

### Development State Management

When development phase or work focus changes, always update the state with `change_context` tool.

**When to Use**:
- Phase transitions (development‚Üítesting, testing‚Üídebugging, etc.)
- Work focus changes (API implementation‚Üíauthentication, etc.)

**Effect**: After state change, this instruction file is automatically regenerated with prioritized instructions for the current phase.

### Development Rule Registration

When receiving new conventions, rules, or constraints from users, always persist them to `project_context` instead of applying temporarily.

**Pre-registration Check**:
1. Search existing rules (`project_context read`)
2. Check for contradictions
3. If contradictions exist, ask user for confirmation

**Important**: Once registered, rules are referenced in all subsequent sessions. Always register to prevent loss.

### Self-awareness of Instructions

`instructions_structure` tool modifies **this instruction file itself**. When using, explicitly state:

**Cautions**:
- Explicitly state changes when executing update/delete/insert
- Warn that "this instruction file will be modified"
- Conflict detection (`detect-conflicts`) activates automatically if external changes exist

### Consistency Check with Existing Rules

When receiving new instructions, always check for contradictions with existing `project_context`.

**Check Procedure**:
1. Search related categories (`project_context read`)
2. If contradictions detected, present options to user
3. Follow user choice to update or maintain existing rules

### Onboarding for Existing Projects

On first run, or if existing `copilot-instructions.md` exists, analyze with `onboarding` tool.

**Behavior**:
- If compatible: Automatically operates in normal mode
- If incompatible: Operates in restricted mode (read-only)
- After reviewing migration proposal, execute with approval

---

**Current: Refactoring Phase**
- Prioritize referencing code quality conventions
- Record change history with `change_context`

---

## üéØ Current Goals

### Ultimate Objective
**Open, Federated AI for Everyone (North Star)** (in-progress)
Establish an open, federated global infrastructure on XMPP where anyone can safely, affordably, and freely utilize advanced AI capabilities. Ensure accessibility (any XMPP client), transparency (visible costs/safety/reasoning), extensibility (ecosystem-driven plugin growth), sustainability (predictable economics), and public utility (protocol-based collaboration without proprietary lock-in).

### üéØ Current Focus
**Open, Federated AI for Everyone (North Star)** (in-progress)
Establish an open, federated global infrastructure on XMPP where anyone can safely, affordably, and freely utilize advanced AI capabilities. Ensure accessibility (any XMPP client), transparency (visible costs/safety/reasoning), extensibility (ecosystem-driven plugin growth), sustainability (predictable economics), and public utility (protocol-based collaboration without proprietary lock-in).

### Next Steps
- ‚è∏Ô∏è Production-Ready Federated AI Infrastructure (2028) (not-started)

---

## ‚ÑπÔ∏è Filtering Notice

**Mode**: `normal` ‚Äî 3 section(s) filtered out

To view all content: `change_context({ action: "update", state: {...}, mode: "full" })`

---

## undefined: phases/phase5-record-field-spans.md

# Phase 5: Record Field Spans

## Overview

**Goal**: Add precise span tracking to record field names for better error diagnostics

**Status**: 33% Complete (Step 1-6 done, Steps 7-9 remaining)

## Completed Work

### ‚úÖ Step 1-6: ExprKind::Record (Commit: 526024f)

- Added `ExprRecordField` struct with `name`, `name_span`, `value` fields
- Updated `ExprKind::Record` from `Vec<(String, Expr)>` to `Vec<ExprRecordField>`
- Parser captures field name spans during record literal parsing
- Type checker uses field name span for diagnostics (key improvement)
- Updated 7 crates: ast, parser, types, runtime, coreir, analyzer, cli
- All 113 tests passing

**Key Achievement**: Type errors on record fields now point to field names, not values

## Current Work

### üîÑ Step 7: PatternKind::Record

**Objective**: Apply same transformation to pattern records

**Changes Required**:
1. Add `PatternRecordField` struct (similar to `ExprRecordField`)
2. Update `PatternKind::Record(Vec<(String, Pattern)>)` ‚Üí `Vec<PatternRecordField>`
3. Parser: capture pattern field name spans
4. Update affected crates:
   - lzscr-analyzer: `hash_pattern_shape()`, `collect_vars()`, `pat_idents()`, `binds_param()`, `binds_name()`
   - lzscr-cli: `rebase_pattern_with_minus()`
   - lzscr-types: pattern type inference

**Estimated Scope**: ~25-30 locations (fewer than Expr)

## Remaining Work

### ‚è≥ Step 8: TypeExpr::Record

- Add `TypeExprRecordField` struct
- Update type expression records
- Estimated: 30-45 minutes (smallest scope)

### ‚è≥ Step 9: Error Display Improvements

- Update `display_type_error_diagnostic()` to use field name spans
- Add golden tests for record field errors
- Example: "Missing field 'age'" points precisely at field name

## Progress Tracking

- Phase 5: 33% ‚Üí 66% (after Step 7) ‚Üí 100% (after Step 9)
- Next Phase: Phase 6 (Error Message Style Guide)


---

## undefined: tasks/step9-error-display-improvements.md

# Step 9: Error Display Improvements

## Objective

Leverage field name spans in TypeError display to provide precise error reporting for record fields. This is the final step that makes all the previous infrastructure work visible to users.

## Implementation Steps

### 1. Analyze Current Error Display

**File**: `crates/lzscr-types/src/error.rs`

**Function**: `display_type_error_diagnostic()`

Review how Type::Record errors are currently displayed and identify where field name spans should be used.

### 2. Update Record Error Reporting

**Key improvements**:

- **Missing field errors**: Point to the field name in the pattern/expression, not the entire record
- **Type mismatch in fields**: Use field name span instead of value span
- **Extra field errors**: Highlight the unexpected field name precisely

**Example transformations**:

```rust
// Before: Error points to entire record literal
{ name: "Alice", age: "30" }
^^^^^^^^^^^^^^^^^^^^^^^^^^ Type error: Expected Int, found Str

// After: Error points to field name
{ name: "Alice", age: "30" }
                 ^^^ Type error in field 'age': Expected Int, found Str
```

### 3. Locate Error Display Code

**Search for**:
- `Type::Record` in error display functions
- Current span usage in record-related errors
- Functions that format type error messages

**Files to check**:
- `crates/lzscr-types/src/error.rs`
- `crates/lzscr-cli/src/main.rs` (error display utilities)

### 4. Update Span Selection Logic

When displaying errors for Type::Record:

```rust
// Use the stored field name span from type information
match &expected_type {
    Type::Record(fields) => {
        // fields is BTreeMap<String, (Type, Option<Span>)>
        if let Some((_, Some(field_span))) = fields.get(&field_name) {
            // Use field_span for error location
            display_error_at_span(field_span, &message);
        }
    }
}
```

### 5. Test Error Messages

Create test cases that demonstrate improved error reporting:

**Test file**: `crates/lzscr-types/tests/record_field_errors.rs` (or similar)

**Test scenarios**:
1. Missing required field
2. Type mismatch in field value
3. Extra unexpected field
4. Field name typo (suggestion)

### 6. Update Golden Tests

If golden test files exist for error messages:

**Location**: `goldens/` or `crates/lzscr-types/tests/goldens/`

Update expected error output to show:
- Field name highlighted (not entire record)
- Precise column/line pointing to field
- Clear "in field 'name'" message

### 7. Documentation

**Optional but recommended**:

Update error message documentation to showcase improved diagnostics:
- Before/after examples
- Screenshots or text examples in `docs/diagnostics-improvement-plan.md`

## Expected Outcomes

### User-Visible Improvements

**Before (Step 1-8)**:
```
Type error at line 5, column 10:
{ name: "Alice", age: "30" }
^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected Int, found Str
```

**After (Step 9)**:
```
Type error at line 5, column 22:
{ name: "Alice", age: "30" }
                 ^^^ Field 'age': Expected Int, found Str
```

### Technical Achievements

- ‚úÖ Field name spans from Step 1-8 are now utilized
- ‚úÖ Error messages point to exact field locations
- ‚úÖ Improved developer experience with precise diagnostics
- ‚úÖ Phase 5 complete (100%)

## Common Patterns to Update

### Pattern 1: Field Name in Error Message

```rust
// Add field name to error message
format!("Field '{}': {}", field_name, type_error_message)
```

### Pattern 2: Span Selection Priority

```rust
// Priority: field_span > value_span > entire_record_span
let error_span = field_span
    .or(value_span)
    .unwrap_or(record_span);
```

### Pattern 3: Diagnostic Context

```rust
// Add context about which field caused the error
Diagnostic {
    message: format!("Type mismatch in field '{}'", field_name),
    span: field_name_span,  // Use field name span
    notes: vec!["Expected Int, found Str"],
}
```

## Validation

### Manual Testing

```bash
# Test with intentional type errors
echo '{ name: "Alice", age: "30" }' | cargo run --bin lzscr -- eval -

# Verify error points to 'age', not entire record
```

### Automated Testing

```bash
# Run type error tests
cargo test --package lzscr-types test_record_field_errors

# Run all tests to ensure no regressions
cargo test
```

## Success Criteria

- ‚úÖ Record field type errors point to field name, not value
- ‚úÖ Missing field errors point to expected location in pattern/type
- ‚úÖ All 113 tests continue passing
- ‚úÖ Error messages are more helpful (verified manually)
- ‚úÖ No performance regression in type checking

## Notes

- This step is primarily about **presentation**, not type system changes
- The infrastructure (field name spans) is already in place from Steps 1-8
- Focus on user-facing error messages and diagnostics
- May require iterative refinement based on actual error scenarios encountered


---

