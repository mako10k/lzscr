# Copilot Instructions

<!-- Auto-generated by mcp-copilot-instructions -->
<!-- Mode: normal -->
<!-- Context: phase=refactoring, focus=AST refactoring, Phase 5 Record Field Spans, PatternKind::Record -->
<!-- Generated: 2025-12-03T09:09:40.532Z -->
<!-- Stats: 0 required, 3 optional (1 filtered) -->

## meta: Tool Usage Guide

This MCP server handles external storage and dynamic generation of instructions. Use the following tools appropriately.

### Development State Management

When development phase or work focus changes, always update the state with `change_context` tool.

**When to Use**:
- Phase transitions (development‚Üítesting, testing‚Üídebugging, etc.)
- Work focus changes (API implementation‚Üíauthentication, etc.)

**Effect**: After state change, this instruction file is automatically regenerated with prioritized instructions for the current phase.

### Development Rule Registration

When receiving new conventions, rules, or constraints from users, always persist them to `project_context` instead of applying temporarily.

**Pre-registration Check**:
1. Search existing rules (`project_context read`)
2. Check for contradictions
3. If contradictions exist, ask user for confirmation

**Important**: Once registered, rules are referenced in all subsequent sessions. Always register to prevent loss.

### Self-awareness of Instructions

`instructions_structure` tool modifies **this instruction file itself**. When using, explicitly state:

**Cautions**:
- Explicitly state changes when executing update/delete/insert
- Warn that "this instruction file will be modified"
- Conflict detection (`detect-conflicts`) activates automatically if external changes exist

### Consistency Check with Existing Rules

When receiving new instructions, always check for contradictions with existing `project_context`.

**Check Procedure**:
1. Search related categories (`project_context read`)
2. If contradictions detected, present options to user
3. Follow user choice to update or maintain existing rules

### Onboarding for Existing Projects

On first run, or if existing `copilot-instructions.md` exists, analyze with `onboarding` tool.

**Behavior**:
- If compatible: Automatically operates in normal mode
- If incompatible: Operates in restricted mode (read-only)
- After reviewing migration proposal, execute with approval

---

**Current: Refactoring Phase**
- Prioritize referencing code quality conventions
- Record change history with `change_context`

---

## üéØ Current Goals

### Ultimate Objective
**Open, Federated AI for Everyone (North Star)** (in-progress)
Establish an open, federated global infrastructure on XMPP where anyone can safely, affordably, and freely utilize advanced AI capabilities. Ensure accessibility (any XMPP client), transparency (visible costs/safety/reasoning), extensibility (ecosystem-driven plugin growth), sustainability (predictable economics), and public utility (protocol-based collaboration without proprietary lock-in).

### üéØ Current Focus
**Open, Federated AI for Everyone (North Star)** (in-progress)
Establish an open, federated global infrastructure on XMPP where anyone can safely, affordably, and freely utilize advanced AI capabilities. Ensure accessibility (any XMPP client), transparency (visible costs/safety/reasoning), extensibility (ecosystem-driven plugin growth), sustainability (predictable economics), and public utility (protocol-based collaboration without proprietary lock-in).

### Next Steps
- ‚è∏Ô∏è Production-Ready Federated AI Infrastructure (2028) (not-started)

---

## ‚ÑπÔ∏è Filtering Notice

**Mode**: `normal` ‚Äî 1 section(s) filtered out

To view all content: `change_context({ action: "update", state: {...}, mode: "full" })`

---

## undefined: conventions/rust-patterns.md

# Rust Coding Patterns

## AST Refactoring Patterns

### Record Field Structures

When adding span tracking to AST record fields, follow this consistent pattern:

**Structure Definition:**
```rust
/// Record field in [context] with field name span tracking.
/// Phase 5: Diagnostics Improvement - enables precise error reporting.
#[derive(Debug, Clone, PartialEq)]
pub struct [Type]RecordField {
    pub name: String,
    pub name_span: Span,
    pub [field_name]: [FieldType],
}

impl [Type]RecordField {
    pub fn new(name: String, name_span: Span, [field_name]: [FieldType]) -> Self {
        Self { name, name_span, [field_name] }
    }
}
```

**Iteration Pattern:**
```rust
// Before: Vec<(String, T)>
for (k, v) in fields { ... }

// After: Vec<TRecordField>
for f in fields {
    // Access: f.name, f.name_span, &f.[field_name]
}
```

### Parser Span Capture

Always capture field name spans during parsing:

```rust
let key_span = ktok.span;  // Capture before consumption
fields.push([Type]RecordField::new(key, key_span, value));
```

### Type Inference with Spans

Use field name spans for diagnostics, not value spans:

```rust
// Prefer field name span for error reporting
map.insert(f.name.clone(), (type_value, Some(f.name_span)));
```

## Testing Requirements

After AST changes:
1. Run `cargo build` - fix all compilation errors
2. Run `cargo test` - ensure all 113+ tests pass
3. Commit with descriptive message including:
   - What changed
   - Why (Phase/Step reference)
   - Impact (tests passing, lines affected)


---

## undefined: phases/phase5-record-field-spans.md

# Phase 5: Record Field Spans

## Overview

**Goal**: Add precise span tracking to record field names for better error diagnostics

**Status**: 33% Complete (Step 1-6 done, Steps 7-9 remaining)

## Completed Work

### ‚úÖ Step 1-6: ExprKind::Record (Commit: 526024f)

- Added `ExprRecordField` struct with `name`, `name_span`, `value` fields
- Updated `ExprKind::Record` from `Vec<(String, Expr)>` to `Vec<ExprRecordField>`
- Parser captures field name spans during record literal parsing
- Type checker uses field name span for diagnostics (key improvement)
- Updated 7 crates: ast, parser, types, runtime, coreir, analyzer, cli
- All 113 tests passing

**Key Achievement**: Type errors on record fields now point to field names, not values

## Current Work

### üîÑ Step 7: PatternKind::Record

**Objective**: Apply same transformation to pattern records

**Changes Required**:
1. Add `PatternRecordField` struct (similar to `ExprRecordField`)
2. Update `PatternKind::Record(Vec<(String, Pattern)>)` ‚Üí `Vec<PatternRecordField>`
3. Parser: capture pattern field name spans
4. Update affected crates:
   - lzscr-analyzer: `hash_pattern_shape()`, `collect_vars()`, `pat_idents()`, `binds_param()`, `binds_name()`
   - lzscr-cli: `rebase_pattern_with_minus()`
   - lzscr-types: pattern type inference

**Estimated Scope**: ~25-30 locations (fewer than Expr)

## Remaining Work

### ‚è≥ Step 8: TypeExpr::Record

- Add `TypeExprRecordField` struct
- Update type expression records
- Estimated: 30-45 minutes (smallest scope)

### ‚è≥ Step 9: Error Display Improvements

- Update `display_type_error_diagnostic()` to use field name spans
- Add golden tests for record field errors
- Example: "Missing field 'age'" points precisely at field name

## Progress Tracking

- Phase 5: 33% ‚Üí 66% (after Step 7) ‚Üí 100% (after Step 9)
- Next Phase: Phase 6 (Error Message Style Guide)


---

## undefined: tasks/step7-pattern-record-field.md

# Step 7: PatternRecordField Implementation

## Objective

Update `PatternKind::Record` to use `PatternRecordField` struct with field name span tracking, following the same pattern as `ExprRecordField` (completed in Step 1-6).

## Implementation Steps

### 1. Add PatternRecordField Struct

**File**: `crates/lzscr-ast/src/lib.rs`

**Location**: Immediately after `ExprRecordField`

```rust
/// Record field in a pattern with field name span tracking.
/// Phase 5: Diagnostics Improvement - enables precise error reporting for pattern record fields.
#[derive(Debug, Clone, PartialEq)]
pub struct PatternRecordField {
    pub name: String,
    pub name_span: Span,
    pub pattern: Pattern,
}

impl PatternRecordField {
    pub fn new(name: String, name_span: Span, pattern: Pattern) -> Self {
        Self { name, name_span, pattern }
    }
}
```

**Note**: Must include `#[derive(PartialEq)]` - required for pattern matching

### 2. Update PatternKind::Record Definition

**File**: `crates/lzscr-ast/src/lib.rs`

**Change**:
```rust
// Before:
Record(Vec<(String, Pattern)>),

// After:
Record(Vec<PatternRecordField>),
```

### 3. Update Parser

**File**: `crates/lzscr-parser/src/lib.rs`

**Location**: Pattern record parsing (~line 2000)

**Change**: Capture field name span before consuming token

```rust
let key_span = ktok.span;  // Add this line
fields.push(PatternRecordField::new(key, key_span, pattern));  // Update this line
```

### 4. Update Affected Crates

#### lzscr-analyzer/src/lib.rs

**Functions to update**:
- `hash_pattern_shape()` (~line 30-80)
  - Change: `for (k, v) in fs` ‚Üí `for f in fs`
  - Access: `f.name`, `&f.pattern`
  
- `collect_vars()` (multiple locations: ~line 520, 750, 1050)
  - Change: `for (_k, v) in fs` ‚Üí `for f in fs`
  - Access: `&f.pattern`
  
- `pat_idents()` (multiple locations: ~line 650, 780)
  - Same pattern as `collect_vars()`
  
- `binds_param()` (~line 900)
  - Change: `fs.iter().any(|(_, v)| binds_param(v, name))` ‚Üí `fs.iter().any(|f| binds_param(&f.pattern, name))`
  
- `binds_name()` (~line 1100)
  - Same pattern as `binds_param()`

#### lzscr-cli/src/main.rs

**Function**: `rebase_pattern_with_minus()` (~line 1983)

```rust
Record(fields) => {
    let mut new = Vec::with_capacity(fields.len());
    for f in fields.iter() {
        new.push(PatternRecordField::new(
            f.name.clone(),
            f.name_span,
            map_pattern(&f.pattern)
        ));
    }
    Record(new)
}
```

#### lzscr-types/src/inference/pattern.rs

**Pattern type inference logic**

Update pattern matching for `PatternKind::Record`:
- Store field name spans in type information
- Use `f.name_span` for diagnostic purposes

### 5. Build and Test

```bash
# Iterative compilation
cargo build

# Fix errors as they appear
# Repeat until clean build

# Run full test suite
cargo test

# Verify all 113 tests pass
```

### 6. Commit

```bash
git add -A
git commit -m "feat(diagnostics): Phase 5 Step 7 - Add field name spans to PatternKind::Record

- Added PatternRecordField struct with name, name_span, pattern fields
- Updated PatternKind::Record to use Vec<PatternRecordField>
- Parser captures pattern field name spans
- Updated lzscr-analyzer, lzscr-cli, lzscr-types
- All tests passing
- Enables precise error reporting for pattern record fields"
```

## Expected Outcomes

- **Pattern match errors** now point to field names precisely
- **Consistency** with `ExprRecordField` structure
- **Scope**: ~25-30 locations updated (less than Expr)
- **Tests**: All 113 tests continue passing

## Key Differences from ExprRecordField

1. **Field type**: `pattern: Pattern` instead of `value: Expr`
2. **Derives**: Must include `PartialEq` (used in pattern matching)
3. **Usage locations**: Fewer than Expr (patterns less common)
4. **Type inference**: Store span in pattern type context

## Common Pitfalls

- ‚ùå Forgetting `#[derive(PartialEq)]` on `PatternRecordField`
- ‚ùå Mixing up `ExprKind::Record` and `PatternKind::Record` during fixes
- ‚ùå Using `f.value` instead of `f.pattern` (copy-paste error)
- ‚ùå Not capturing `key_span` before token consumption in parser

## Success Criteria

- ‚úÖ All crates compile without errors
- ‚úÖ All 113 tests pass
- ‚úÖ `PatternRecordField` struct defined with correct derives
- ‚úÖ Parser captures field name spans
- ‚úÖ All pattern record iterations updated to new format


---

